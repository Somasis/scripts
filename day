#!/bin/sh
# day - write, manage, and remind to write daily journals on a regular basis

me="${0##*/}"

EDITOR="${EDITOR:-vi}"
daylog_dir=~/daylog

is_date() {
    [ $(printf '%s' "${1}" | grep -Ec "^[0-9]{4}-[0-9]{2}-[0-9]{2}$") -ne 0 ] || return 127
}

# get_date
# get_date <+/-><number> [from date]
get_date() {
    case "${1:-0}" in
        0)
            date +%Y-%m-%d
        ;;
        -*)
            in_seconds=$(expr 86400 \* "${1:1}")
            get_date_from=$(date +%s -d ${2:-$(get_date)})
            final_date=$(expr ${get_date_from} - ${in_seconds})
            date +%Y-%m-%d -d "@${final_date}"
        ;;
        +*)
            in_seconds=$(expr 86400 \* "${1:1}")
            get_date_from=$(date +%s -d ${2:-$(get_date)})
            final_date=$(expr ${get_date_from} + ${in_seconds})
            date +%Y-%m-%d -d "@${final_date}"
        ;;
        today)
            shift
            get_date
        ;;
        yesterday)
            shift
            get_date "-1" "$@"
        ;;
        tomorrow)
            shift
            get_date "+1" "$@"
        ;;
        *)
            if is_date "${1}";then
                printf '%s' "${1}"
            else
                printf 'day: %s is not a valid date or command\n' "${1}" >&2
                return 127
            fi
        ;;
    esac
    return $?
}

mode_help() {
    case "${1}" in
        --help-description)
            printf 'Display this help message.\n'
            exit 0
        ;;
        *)
            cat <<EOF
usage:
    day COMMAND [ARGS...]
    day [DATE]

commands:
EOF

        for cmd in $(grep "^mode_[-_A-Za-z]\(\)" "$(command -v ${0})" | cut -d'(' -f1 | cut -d_ -f2-);do
            cmds="${cmds} ${cmd}"
        done

        OLDIFS="${IFS}"; IFS=:
        for path in ${PATH};do
            for cmd in "${path}"/day-*;do
                if [ -e "${cmd}" -a -x "${cmd}" ];then
                    cmds="${cmds} ${cmd##*/day-}"
                elif command -v mode_"${cmd}";then
                    cmds="${cmds} ${cmd}"
                else
                    continue
                fi
            done
        done
        IFS="${OLDIFS}"; OLDIFS=

        cmds=$(printf '%s\n' ${cmds} | sort -ud)

        cmd_padding=0
        for cmd in ${cmds};do
            cmd_length="${#cmd}"
            [ "${cmd_length}" -gt "${cmd_padding}" ] && cmd_padding="${cmd_length}"
        done

        cmd_padding=$(( cmd_padding + 2 ))

        for cmd in ${cmds};do
            desc=$(day "${cmd}" --help-description)
            [ -z "${desc}" ] && desc="No description."
            printf "    %-${cmd_padding}s%s\n" "${cmd}" "${desc}"
            cmd=; desc=;
        done
        cat <<EOF

If only a DATE is given, the log command is used.

DATE must be formatted in YYYY-mm-dd format.
EOF
        ;;
    esac
    return 0
}

mode_check() {
    if [ "${1}" = --help-description ];then
        printf 'Exit with 0 if an entry has been made today, and 1 if it has not.\n'
        exit 0
    fi

    check_date=$(get_date "${1}") || return $?
    if ! [ -f "${daylog_dir}"/"${check_date}".gpg ];then
        [ "${check_date}" = "$(get_date 0)" ] && check_date="today"
        printf "day: you haven't written a log for %s yet!\n" "${check_date}" >&2
        return 1
    fi
}

mode_read() {
    if [ "${1}" = --help-description ];then
        printf 'Display an entry.\n'
        exit 0
    fi

    read_date=$(get_date "${1}") || return $?
    if ! [ -f "${daylog_dir}"/"${read_date}".gpg ];then
        printf "day: you haven't written a log for %s yet!\n" "${read_date}" >&2
        return 1
    fi
    gpgcat "${daylog_dir}"/"${read_date}".gpg
    return $?
}

mode_log() {
    if [ "${1}" = --help-description ];then
        printf 'Create a new entry.\n'
        exit 0
    fi

    log_date=$(get_date "${1:-0}") || return $?
    if [ -f "${daylog_dir}"/"${log_date}".gpg ];then
        gpgedit "${daylog_dir}"/"${log_date}".gpg || return 255
    else
        touch "${daylog_dir}"/.${log_date}
        chmod 700 "${daylog_dir}"/.${log_date}
        printf '%s\n' '' '# Lines beginning with # will be deleted.' > "${daylog_dir}"/.${log_date}
        if [ -n "$(mode_list -q | tr -d '\n ')" ];then
            for f in $(get_date -1 "${log_date}") $(get_date -2 "${log_date}");do
                printf '#\n'
                printf '# %s:\n' "${f}"
                mode_read "${f}" | sed 's/^/#   /' 
            done >> "${daylog_dir}"/.${log_date}
        fi
        "${EDITOR}" "${daylog_dir}"/.${log_date} || return 255
        sed -E -i '/^#/d' "${daylog_dir}"/.${log_date}
        if [ $(tr -cd '[:print:]' < "${daylog_dir}"/."${log_date}" | wc -c) -gt 0 ];then
            gpgencrypt -o "${daylog_dir}"/"${log_date}".gpg "${daylog_dir}"/."${log_date}" || return 100
            rm -f "${daylog_dir}"/."${log_date}"
            return 0
        else
            printf 'day: log for %s is empty, removing\n' "${log_date}" >&2
            rm -f "${daylog_dir}"/."${log_date}"
            return 1
        fi
    fi
}

mode_list() {
    if [ "${1}" = --help-description ];then
        printf 'List entries.\n'
        exit 0
    fi

    list_quiet=false
    [ "$1" = '-q' ] && list_quiet=true
    for f in $(find -name '*.gpg' "${daylog_dir}" | sed 's|.*/||g;s|\.gpg||' | sort -n);do
        if "${list_quiet}";then
            printf '%s\n' "${f}"
        else
            f_summary=$(gpgcat "${daylog_dir}"/"${f}".gpg | head -n1 | cut -d' ' -f-20)
            printf '%s - %s...\n' "${f}" "${f_summary}"
        fi
    done
}

mode_grep() {
    if [ "${1}" = --help-description ];then
        printf 'Grep through entries.\n'
        exit 0
    fi

    cd "${daylog_dir}"
    gpggrep "${@}" *.gpg | sed -E 's/^([0-9]{4}-[0-9]{2}-[0-9]{2}).gpg:/\1:/'
}

mode_missing() {
    if [ "${1}" = --help-description ];then
        printf 'Print missing days since you started, until the current day.\n'
        exit 0
    fi

    missing_quiet=false
    [ "$1" = '-q' ] && missing_quiet=true
    missing_date=$(mode_list -q | head -n1)
    today_date=$(get_date 0)
    until [ "${missing_date}" = "${today_date}" ];do
        missing_date=$(get_date +1 ${missing_date})
        if ! [ -f "${daylog_dir}"/"${missing_date}".gpg ];then
            if "${missing_quiet}";then
                printf '%s\n' "${missing_date}"
            else
                printf '%s is missing\n' "${missing_date}"
            fi
        fi
    done
}

[ "$#" -eq 0 ] && mode=log

die=false
until [ $# -eq 0 ];do
    case "${1}" in
        help|check|log|list|read|missing|grep)
            mode="${1}"
            shift
            break
        ;;
        today|yesterday|tomorrow)
            mode=log
            break
        ;;
        *)
            is_date "${1}" && mode=log && break

            if command -v "day-${1}" >/dev/null 2>&1;then
                command=day-"${1}"
                shift
                exec "${command}" "$@"
            fi
            printf 'day: %s is not a valid date or command\n' "${1}" >&2
            exit 127
        ;;
    esac
done

"${die}" && exit 127

[ -d "${daylog_dir}" ] || mkdir "${daylog_dir}"

mode_"${mode}" "$@" && exit $?

